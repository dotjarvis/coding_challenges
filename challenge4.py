# SAT DEC 17, 2022


# QUESTION 1


# Given a sentence as txt, return True if any two adjacent words have this property:
# One word ends with a vowel, while the word immediately after begins with a vowel (a e i o u).
# Examples
# vowel_links("a very large appliance") ➞ True
# vowel_links("go to edabit") ➞ True
# vowel_links("an open fire") ➞ False
# vowel_links("a sudden applause") ➞ False


# # SOLUTION
# def vowel_links(txt):
#     vowels = ['a', 'e', 'i', 'o', 'u']
#     txt_array = txt.split(' ')
#     index = 0
#     for word in txt_array:
#         index += 1
#         if index < len(txt_array):
#             if word[-1] in vowels and txt_array[index][0] in vowels:
#                 output = True
#             else:
#                 output = False
#     return output
#
#
# print(vowel_links("a very large appliance"))
# print(vowel_links("go to edabit"))
# print(vowel_links("an open fire"))
# print(vowel_links("a sudden applause"))


# QUESRTION 2


# "Loves me, loves me not" is a traditional game in which a person
# plucks off all the petals of a flower one by one, saying the phrase
# "Loves me" and "Loves me not" when determining whether the one that they love, loves them back.

# Given a number of petals, return a string which repeats the phrases
# "Loves me" and "Loves me not" for every alternating petal,
# and return the last phrase in all caps. Remember to put a comma and space between phrases.
# Examples
# loves_me(3) ➞ "Loves me, Loves me not, LOVES ME"
# loves_me(6) ➞ "Loves me, Loves me not, Loves me, Loves me not, Loves me, LOVES ME NOT"
# loves_me(1) ➞ "LOVES ME"


# # SOLUTION
# def loves_me(n):
#     final_string = ''
#     for number in range(n):
#         if number % 2 == 0:
#             if number == n - 1:
#                 final_string += 'LOVES ME'
#             else:
#                 final_string += 'Loves me, '
#         else:
#             if number == n - 1:
#                 final_string += 'LOVES ME NOT'
#             else:
#                 final_string += 'Loves me not, '
#
#     return final_string
#
#
# print(loves_me(3))
# print(loves_me(6))
# print(loves_me(1))


# MON DEC 19, 2022


# QUESTION 1

# A Collatz sequence is generated by repeatedly applying
# the following rules to an integer and then to each resulting integer in turn:
# If even: divide by 2.
# If odd: multiply by 3, then add 1.
# The Collatz algorithm has been tested and found to always reach 1 for all positive integers.
# Create a function that, when given two positive integers a b, 
# returns the string "a" if integer a took fewer steps to reach 1 than b 
# when passed through the Collatz sequence, or "b" if integer b took fewer steps to reach 1 than a.
# Examples
# collatz(10, 15) ➞ "a"
# # Because 10.0 - 5.0 - 16.0 - 8.0 - 4.0 - 2.0 - 1.0: 6 steps
# # 15.0 - 46.0 - 23.0 - 70.0 - 35.0 - 106.0 - 53.0 - 160.0 - 80.0
# - 40.0 - 20.0 - 10.0 - 5.0 - 16.0 - 8.0 - 4.0 - 2.0 - 1.0: 17 steps
# collatz(13, 16) ➞ "b"
# collatz(53782, 72534) ➞ "b"

# # SOLUTION
# def collatz(a, b):
#     a_num = b_num = 0
#     while a != 1:
#         if a % 2 == 0 and a != 1:
#             a /= 2
#             a_num += 1
#         elif a % 2 == 1 and a != 1:
#             a = a * 3 + 1
#             a_num + 1
#     while b != 1:
#         if b % 2 == 0 and b != 1:
#             b /= 2
#             b_num += 1
#         elif b % 2 == 1 and b != 1:
#             b = b * 3 + 1
#             b_num += 1
#     print(a_num, b_num)
#     if a_num > b_num:
#         return "b"
#     elif b_num > a_num:
#         return 'a'
#
#
# print(collatz(10, 15))
# print(collatz(13, 16))
# print(collatz(53782, 72534))


# QUESTION 2


# Given a predetermined rate from a dictionary, write the function that
# will return the time it takes for a certain amount of people to paint
# a certain amount of walls.
# The "rate" dictionary shows how many minutes it takes "people" people
# to paint "walls" walls. At that same rate, how long should
# it take based on the new variables. Return the minutes as an integer. No rounding is necessary.
# Example
# # It takes 22 minutes for 10 people to paint 10 walls.
# # How many minutes does it take 14 people to paint 14 walls?
# rate = {
#   "people": 10,
#   "walls": 10,
#   "minutes": 22
# }
# time(rate, people, walls) ➞ 22

# # SOLUTION
# def time(rate, people, walls):
#     return rate["minutes"] * (walls / rate["people"])
#
#
# rate = {
#     "people": 10,
#     "walls": 10,
#     "minutes": 22
# }
#
# print(time(rate, 14, 14))


# QUESTION 3


# Create a function based on the input and output. Look at the examples, there is a pattern.
# Examples
# secret("p.one.two.three") ➞ "<p class='one two three'></p>"
# secret("p.one") ➞ "<p class='one'></p>"
# secret("p.four.five") ➞ "<p class='four five'></p>"


# # SOLUTION
# def secret(txt):
#     msg = ''
#     txt_split = txt.split('.')
#     for number in txt_split[1:]:
#         msg += number
#         if number != txt_split[-1]:
#             msg += ' '
#
#     return f"<{txt_split[0]} class='{msg}'></p>"
#
#
# print(secret("p.one.two.three"))
# print(secret("p.one"))
# print(secret("p.four.five"))


# QUESTION 4


# There are three cups on a table, at positions A, B, and C.
# At the start, there is a ball hidden under the cup at position B.
# Image cups where ball is under middle cup
# However, I perform several swaps on the cups, which is notated as two letters.
# For example, if I swap the cups at positions A and B, I could notate this as AB or BA.
# Create a function that returns the letter position that the ball is at,
# once I finish swapping the cups. The swaps will be given to you as a list.

# Worked Example
# cup_swapping(["AB", "CA", "AB"]) ➞ "C"
# # Ball begins at position B.
# # Cups A and B swap, so the ball is at position A.
# # Cups C and A swap, so the ball is at position C.
# # Cups A and B swap, but the ball is at position C, so it doesn't move.
# Examples

# cup_swapping(["AB", "CA"]) ➞ "C"
# cup_swapping(["AC", "CA", "CA", "AC"]) ➞ "B"
# cup_swapping(["BA", "AC", "CA", "BC"]) ➞ "A"

# # SOLUTION
# def cup_swapping(swaps):
#     position = 'B'
#     for swap in swaps:
#         if position in swap:
#             position = swap.replace(position, "")
#     return position
#
# print(cup_swapping(["AB", "CA", "AB"]))
# print(cup_swapping(["AB", "CA"]))
# print(cup_swapping(["AC", "CA", "CA", "AC"]))
# print(cup_swapping(["BA", "AC", "CA", "BC"]))
# print(cup_swapping(["AC", "CA", "CA", "AC"]))
# print(cup_swapping(["BA", "AC", "CA", "BC"]))


# TUESDAY DEC 20,2022


# QUESTION 1

# In mathematics, the Fibonacci numbers, commonly denoted Fn,
# form a sequence, called the Fibonacci sequence,
# such that each number is the sum of the two preceding ones, starting from 0 and 1:
# Fibonacci Sequence and Fibonacci Sequence 2
# for n > 1
# The beginning of the sequence is thus:
# 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...
# The function fib_fast(num) returns the fibonacci number Fn, of the given num as an argument.
# Examples
# fib_fast(5) ➞ 5
# fib_fast(10) ➞ 55
# fib_fast(20) ➞ 6765
# fib_fast(50) ➞ 12586269025


# # SOLUTION
# def fib_fast(num):
#     if num <= 1:
#         return num
#     a, b = 0, 1
#     for i in range(num - 1):
#         a, b = b, a + b
#     return b
#
#
# print(fib_fast(5))
# print(fib_fast(10))
# print(fib_fast(20))
# print(fib_fast(50))


# QUESTION 2


# You are given a list of integers and a target number.
# Your task is to find all the pairs of integers in the list that add up to the target number.
#
# For example, if the list is [1, 2, 3, 4, 5] and the target number is 7,
# the pairs that add up to 7 are (2, 5) and (3, 4).
#
# Write a function find_pairs(nums, target) that returns a list of all
# the pairs of integers in nums that add up to target.
# The pairs should be returned in the form of tuples.
#
# Example:
#
# find_pairs([1, 2, 3, 4, 5], 7) --> [(2, 5), (3, 4)]
# find_pairs([-1000, -999], -1999) --> [(-1000, -999)]
# find_pairs([1000, 999], 1999) --> [(1000, 999)]
# find_pairs([1, 2, 3, 4, 5], 7) --> [(2, 5), (3, 4)]
# find_pairs([1, 2, 3, 4, 5, 6], 7) --> [(1, 6), (2, 5)]
# find_pairs([1, 2, 3, 4, 5], 10) --> [(2, 5), (3, 4)]
# find_pairs([5, 5, 5, 5, 5], 10) -->[(5, 5), (5, 5), (5, 5)]


# Notes:
# The input list nums will contain at least two elements and at most 1000 elements.
# The elements of nums will be unique and will be in the range from -1000 to 1000.
# The target number will be in the range from -1000 to 1000.


# # SOLUTION
# def find_pairs(lst, target):
#     all_pairs = []
#     for list1 in lst:
#         for list2 in lst:
#             if list1 + list2 == target and (list2, list1) not in all_pairs:
#                 all_pairs.append((list1, list2))
#     return all_pairs
#
#
# print(find_pairs([1, 2, 3, 4, 5], 7))
# print(find_pairs([-1000, -999], -1999))
# print(find_pairs([1000, 999], 1999))
# print(find_pairs([1, 2, 3, 4, 5], 7))
# print(find_pairs([1, 2, 3, 4, 5, 6], 7))
# print(find_pairs([1, 2, 3, 4, 5], 10))
# print(find_pairs([5, 5, 5, 5, 5], 10))


# QUESTION 2

# Write a function that takes in a list of integers and returns the
# second-largest number in the list. Your function should return -1
# if the list has fewer than two elements.
# Your solution should have a time complexity of O(n) and should not modify the original list.
# Example:
# assert second_largest([1, 2, 3, 4, 5]) == 4
# assert second_largest([5, 4, 3, 2, 1]) == 4
# assert second_largest([1]) == -1
# assert second_largest([]) == -1

# # SOLUTION
# def second_largest(numbers):
#     if len(numbers) <= 2:
#         return -1
#     num2 = numbers[:]
#     num2.sort()
#     return num2[-2]
#
#
# print(second_largest([1, 2, 3, 4, 5]))
# print(second_largest([5, 4, 3, 2, 1]))
# print(second_largest([1]))
# print(second_largest([]))


# QUESTION 3


# You are given a list of integers nums and a positive integer k.
# Your task is to partition the list into k contiguous sublists
# such that the maximum sum of any sublist is minimized.

# Write a function partition(nums, k) that returns the minimum possible maximum sum
# of the k sublists.

# EXAMPLES
# partition([1, 4, 3, 2, 5, 6, 8, 7, 9], 3) -> 17
# partition([1, 2, 3, 4, 5], 2) -> 9
# partition([1, 2, 3, 4, 5], 3) -> 7
# partition([1, 2, 3, 4, 5], 4) -> 6
# partition([1, 2, 3, 4, 5], 5) -> 5
# partition([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) -> 25
# partition([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) -> 17

# Notes:
# The input list nums will contain at least two elements and at most 1000 elements.
# The elements of nums will be unique and will be in the range from -1000 to 1000.
# The value of k will be in the range from 2 to len(nums).

# SOLUTION
# def partition(nums, k):
#     def possible(x):
#         cnt = 1
#         cur = 0
#         for n in nums:
#             cur += n
#             if cur > x:
#                 cur = n
#                 cnt += 1
#         return cnt <= k
#
#     low = max(nums)
#     high = sum(nums)
#
#     while low < high:
#         mid = (low + high) // 2
#         if possible(mid):
#             high = mid
#         else:
#             low = mid + 1
#
#     return low
#
#
# print(partition([1, 4, 3, 2, 5, 6, 8, 7, 9], 3))
# print(partition([1, 2, 3, 4, 5], 2))
# print(partition([1, 2, 3, 4, 5], 3))
# print(partition([1, 2, 3, 4, 5], 4))
# print(partition([1, 2, 3, 4, 5], 5))
# print(partition([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2))
# print(partition([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3))
